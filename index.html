<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f8f1fbc22093d9275375063271d5dd7dd4a2e4c4a7742ddb73028a7e97f049121b07302459e52b1bcac4ac1ec0f6f55232887c747cf9581c755e22d399f47c7843f925c8aa7ba9c4ea5338ba5ab5243de0edd3e9a331cff833522c1371ae048227d132a9a47da23bf7f830d84e99d50cafa094a5f2129f5d9c80a6185675de92524f346acf5f82aab62a0bda44a36c2611b5eb67cd1ffda80f8583ac96284b09f7571df8aba7bc3416edce27c25ad6c3c51f0770f89522e6953f678ebfcd7150136a6793b8571a8d98e1f626a849b1170aaf6f2f907635b147611b2bf7e86fc58c43f58467504eb0a70f30bd723a1eff4be7612f23fd637e4bbdf16aa180f793e89556956556d8fbd2b0ddcfe36f58c298875e8a1491f2e248307c7164d996cf85760242557254162afeeea1e34edc8d80413dfb6c6be47f414b11e76ba97007d004c5b4a22185c32d7aeb93f6b81c1ae4daf176f30591b72686b4981e28bce68db0dcdd8f485da034cf05c65abd4d4d3e4ae23b8dccccb61e17c7000b5779cfc078bc6e50226af8db1a101ea340a3849c06d7427f53ede88ad368b153799eb5c2d839d4cfc78b7284c0d3db7ae2664cc81c297cb56fb4b542bc2631b33e492ada8008faa3de0db145ad5a37dd80275d77cbf957f5acf62052490eb4f0da1d19d4b5569cf65027e7d6d606e05689a5bfcf5ad0c03f9a2f6dccd9826c9429e925659c1fe167e1f459bfbb620c6886bdfd1c05c4cc7b314335c523a4123450525694c16f29ca944652641a74d5641ae6df4e58315ff8ebb45d9e60d67e917104a2a99741121a2e214010ea43f6d2ea3a0dcf990e4c8717ee4d2b68041fb9cc166c80f8ae52f332b7660f6d1494989ea76f4a007a1238e4477fb95a1f15428795b1caedcf0e05adb05a1eb9425cbcbd09b50fe9e5475d5c1d2b97f57b54bd35eb100c2186a7749bebaf10475fdd34a2bf1b9d14bd20b4c99bfc964746e62743f910d753d75f7680e85ee11128dc1e20fdf39700c4e494ea2444fb52fb08960996a5b679a4b7e1b5016d2b0b5a290ec2c855f0cf3e7ef1d7bc828189480849ced7c6beadc7d77db42e4da96a6579d6fbbbd28f204f0d9f8af7869109914d2ecb3d6e97625efb6bc989fd56329a9810b9a5d42a3631e78232e6f61beea290def02071663efe8a6106322b9c54af784ba0756ca7ca0171335f43e0b3deecf84710d0b0d2aa22b28b748f9018def4f88e02aec3800195a56de9167c99ae430d0d02c608cafd586f6da38cc47c58533871354e581094ed921e38b08afb87a17916ff678b88f03a274d3f81a81f3bad1de3a8afebfbee86e63033ceddfd941c07f7f468a0c9a36afc6cea0ba219dac7e3699c6c5e4edf9ddff849437d50640e7c6417420a99954baa7a4886e4b040aa3d6e0ee909d0239f0ef8220633b4984a6ff62343a21a48feea809a7bab41f0c2c7b9e548bdd160738e9fd76c2fba93292c87b52217dac1a3c312e648f5d0c557d6742d8a8f84e993c93b8571f13c1212767d63d01ff5441df378c2841886b21e60000cf2926ef00c32c9e642437a1a4a999ab6c7d4c829439a35673cf6338eed8f7edb9f2dd477e395df2ee45c86590a0b6b38e8fd4772ac04e3aea15515900f692fc321ccdd859465f2838ad9127321c4495b589679bb0cfdd1ca84ed13020166191f25c309ba2ce31ae5b54448f47906de77cca2d170ab371b67a770a39c0ea175da665aff07268ec6afe7ec9c00c51644cf904014916dd0706af2c8ca6ce08dd45b108c37707e56ed11aab03feb8b32cae493f52e51e3447618710107a2b2853ae640ef6d9905d449d8731bc11abf0d8afb373b976bef23af0c1a2291add684d9e8518d7138f74e726fdf248c465dd42ad2b7f92607073b797d9e6374efbb735aca15a95f449e1a116d7c3ea4e6bfb2269a2d98e4260dab16a08c9b5b7fdfc7c318955aebc1fa49bd1f4f7e7976b934a86d4f238fe565100d20950036e104319f46371171a0300cfb64d91fecc7515a046318fafda1029b710f175251fa30b2ba21bf273d3c68cf23b49b723af8eab5780eb0e5c39812bd1357a69a86d3f77ed7967fbb29ce2580259e1b6edb7e3384129e6c92d8cd0164b0457c55f0a624c7a8570abed579e3c3ad6cfb91d68c27eafb39aa8ac743d7d5eb971525f8cc106d9e63f5778d8879876638786a8f39c223e84ed6eeb649fc3cbde74437f32a51612d91910848f72a3eb92149b331de53dd77527ba118705b65f1a392e743a3ba7eb5aae801284249f4cfe4fefe2cb4dfc23b6e6218c5095a5df07e42d742eecb187d4dd34242a820d23002b0dc5cd0b97a198bcf887cff5c814bb1e8953042554de07a764aa197e16999013804202d3e18d302a73a528efd4e67f1a88b86067f72b5abdb8630506c74f667449915ac740f290b4e4ae9e914fd25012fea72f9fa5582577ed5e7fa69b158955d4c40b3befce3a1a7c734901b5a932919b1f1ca5fa826648c8be1922d9e6f27d7b3c8ad027f739ef36b786b715d665a3a8a3924e88154d18b4089d31c7720bc4516868903f27afb7618a9f0b1622489814ded3bf19325126b9d7a709654a42b4a12a3a490fa5d5e198e9a16a6537f2138f0aa03ecf180406ae591fd931f94794ed6b66cf822a64b3a07776f667b96dbe4470d0ce1e2ef159be0f674032ded134194d99f93e46310279a70395b6af9a31387a118de3ddfd0967c10a7646c8f21c89e9ab86dc8478afc2dabf514593840626924f530e5f4ec09d845f38601bed2c915462f974fcb3975504a73de0a7b0278dda482b36ee69703152f45a796a28653d3691f8760a27753f8b7a8827593dee59d36b19cf9955a3368fa14aedcdc9669a5f8b0991bbf1b265f7e1104bb4ef7880edbf5331006ecee8d71e4bed22fe085d72ff8a38d5f2e36cea87f7c2911952c01226e1c431419c99b89dde439be99b59678fe1d5570957311a7707cec0c540e1bc6f1d66606dc6684809a8c5d4ca96a27247f23015797256fa9530769fe7930e46a36d030dc6ddaee4b9d29bd01c8e7e169bee472329e9cb30a3a9f0b3e1e1275d9df3392f0a30b9f0d3c81483632b6b763ece41fc5a16940118ac63140f338419decad33d68752e31fe5818e3a0f0570ed95e32f4ab78acf0fd306c3f60780790a55340bb39844ff904a142561436d1eb128c27a5858f6afc9141a0162a9aa815ca4e830cfc7ea57465a3afbadb8813a8b61c34d18b1003d8dee916802f92e1f0a6001a46cbc9c949dee87ce2e9bea0e468f461b253946db0c51fe32560f5eb46cad8bfa73cb836f0c966b43e222004e0351171018a90f77be4e07d6b07282c3971c3089fb422d98ab134b39e52d92546c79042963567980226dfac7a50aa25255c7dca879ead589825dac42b8bf5f2ff2397263f809d5d37be6d60eb43c170711ea23e39cfe9e5fe982b9ebe8a3bfde6cdada64c10c28435820c580d8f0f1366fb373b0f58ac8b1255fe126969ac7aeaa9d33e05483b32a542d62fdb1702eadaf26f05ee88a0e4f4a31ba2cc0a7ec4cecfc375459e6819937d80224aea816fd61e86b2a4ea4e58a47afc033e6809d54efc9483b32486e05b8d6d2f720776f24bf3ec3a89eaf9c29dc7923d7a147bd1a377f39bdcf679e69a57c649079147862e50fcd4ead28583bdb2167b51e28e6e8e5522f594aecafa5ed042f1972e3e34b7875f5e84128c7d8acde12e3ebbc9bffdd86fdffebc1ab9b69fcd47b09be2b30e7c06fa72506688c759db577a76c6f1dd56522e6ec65da359e7261accbccbd108667d06312af6ac4c106675c5e22dad1d20b1ebf7967d4e2bab70087d9e576467879f3f3b83379909463b319a0c3d689651370aab8ece8413399d609266b4d331ae43c776a38d4b93dc081bb9e5dcaa36b08a48ba40ef140cfc455726493cdab0059caf54f025adb32c77d5c314bc217c723b4f411718df1addec6b5df6887165ff73e4ea9e5e107121f14381c88f8e7847583b66dd113b407086a7f77cb01aefa3dc6f0ec841848d2aec299a8be103caed58c72522f41baccc6d0f564eed89b089d80de1e4015dda1943b1ff84d60444e6c1c9b95093e9f16e923b4be77fe1d6ad83a3b84a9b86557ef488d05b3e8ad502915e8f11394ba8343f335ec45bbfde8594d1cdbcca1219997bbb7aa748b428ef358a08df5948550c1bf2fa0128add6da48ff57ff69b98b0736a2170f32c3fcca255eda2de67564d9d1b178a5e8d53a61a08ee18e12fd117f534fbdb2392f103c3a0c5dc7445543b775f4633b7e63db42f695b2e8d09afcae1642e3c8145b77807b7bcd9162ae15746f32aafb6a6577150ece2ce5b4b6232b76b08bcaddb3543a1bdef616633846fc4996d99697a4f71eb8317df1046987d4b804aeec0701429c0f2eca9c7f24d03e72534a0f0d469ea6051f18133c78f71f52be850e7ee25c68509eaea9c8ae81e458739f40ff3349072a3e22a14423a5ca95861f50005292a3afff3486b75dd1ee055258ba6c7c71ca004e53bb78c3a9c360cd3b40e401362ebe496e95d6da73f67147572d331b4b40b240b2f04bb9b9f0d9016cccd3ef01c9c344e99548b7dda753bdecb1f562dc23876d1ae5043a7e02965cebe8628960d344d57b4fd7bde96cf2e670f8aff8f92a91e0c88cd04ec22258dc51e01f8821e652a94a2e2da1030ce43a5703d85eeef4a3dc9ebfb14e2101e222f0dcd848975adf1c975930809fd264f60ea2703b258c9e898626a962ad80e17c575fd4460327084ddf6899e3c2b414c1acb26377db60f2fb4cb67b5c82b15b98faba5254d1aef075e07530bfc8d3e59f886e79dc9ca0736636ab5dd9af3b8addda6854a74c4dddc444ad207955929e5747c7e4975c6a13377fa6f46fd87b0afe9680f7bd82064c2ab11fc5a4a53195ce44a58409ec2de870cbc6f1ff06d3c5337e89da67a07221fff09e22c95d4cfd051e049de5574588765537f1cf8af096e9ac265cab8fde3a2fadcdedbc15fae97e9a6951fff7036860e32d0bb0e0dd2a53e2963b61070a6874b107f81a4adac55466ef731012cc16f91b9d6eb6f82578cf6ded8f8d0a13e5078085529242128e623f1d9cd7d3486c84472d733220ba8940a8ade93c07d5ae869ce30c303769b079ef6280c973027666d57588ba2ee9c4e438f61e0f3a2e82b3c3796a4a6d5b1ad118ba55a0473807f29a762f137f9918170aeb8c79b2ba2176c19dfba39dd7ddc46a8de8fad9de036f9335a20b7c5922b18cc61ae95a528af279024d83b4143c7ecab06bd34767dc900ffa91b6fbfe12dd41cf5e0b7e7b3af28c47c997c7b356c90fcb0f3abf872303d56a36514fda8365be9135e7a95b447c4ea6695cbdbb7d8cba3bc13a0eeaec24d87d5d234eea3c949a8d4ebf63992f4c85fe7bc0ba054cfecaf294a825ffa06afc45564a3b4cfd1ca219b71bebcfbeec337b5366dd72873c9d72e52d49e3b4d533221b8379fc897dbcb7f5c23adf396628aa95fd2ee49bc4562c898a54eae9d1cb1438de2ab79b1dc75fc72a51954d06b9b385fe1ed1247e320d4b7935191c4f60ac5009a1cfaddd9caa865ff89873d6c5af929fe25bcc9a994cdae39d9a07797d6663f5ec69c5aaa801f8059230e5bceeddc2c53fa0f3fa2efa79df6237d4ec78ce9613f0b883bd3b5371aafd9751e53a1c4ba35d026cb28e41a7330c905c27c7064e3af876a9e350de513e9e74b62b25995bd7294eef510f0dd8e8418cb31d0c7ec71fd25704e886562e75d953a49c8680fc46503ee32d98204f6677b14b4e9df91505df86a627589b703d9c22270e135be058e24b07aa71df9845ddcfcc5b7b3904e5d1e62a810c4c91f24b181f4b07781064289633aedad451c3e3748603e10cc634f3ac86d6ba4413791f9e0bce1edf0a2ca9e22dc9f3f4d5ee082127e7f54cbcae6d44b1fedca43dc7da9b80f6b5f3f201d3d2ba94f157bbc824dca3389511ab631d6de0af23022a52d4c504b68943823a9b266027f346d89784ba1c948ce424f365d07af445bb05dae86b840213c2ecb3f0bc9384492c4ddde869a0f580bbbfd80a01cace6cec81a577d1b5f0d769e0d8ca52aeb6575d3712ec0693d3adbeaeb6d308fc592a5c477dacb3c8395296917ee3104cd1456a2d96ce1fcce9bd5fc383bb6ea49b004969b04488dbd4b920966b210820d0bbb2bae4803ad9732602e010b920c93e97ad8e75c013767b9025f79d60e9f5f603fdccae71e49e9cbc0f57c5534b19a5db4aa7947fede2c87c9d5d239dc946b9f9e454a1152148530e4b72b37b7e45f550143ff83f6c284d374bfd43413b2550610904a995d4aa22e8319d4cc655e6d1988a9f40f1e851c096759e91f1aaf3a2af22dddf7f5984aee051320cffc99be7e29792f4a929efbe83917eaab15ca78a5fba7afffdf3c910e07d7fb9f5485c46da8a991fe0c23a074d53927d0b4c77739b8b8218c077047736195f64cc4d4814ad5a6c92e7f96ea3c90315ac7e9e80cd3f47707faf9f3ae70c956134490155b3add1fa5020236957fb1952c317d29373eb75977f3fd837de92d13b59e676f4fca6e744a28cfe6999c03bff16389c4adbd6a8d92fcbab457857de98033ab2bba95308cb7b1d33823daaa72cbaeb3b4bd43f6ef11d5b983ad19517c5a8b6f1fa3d6ae014a5d3a89d0628765838c93f183de7c255ea8097c9d897c8a7f3a3d4f79966fff3de9bbe3cc7993832200798bc4b82e750723eea236aeea2e297c78f9e9867c8d957447b4528b4afd9cd3814649c1f5d233184dd9e1bf43fc0fc41146f40d2c491d2f6f29cde8ffdd7bf7aabfb541ed5215eb0dcfc4a9ed27850e641a1ec6e4b02343dafbb565ffaa12ac166b6c787bd17b287f2714666af0e23956b3dd127e3785f79969061f0f68355c3980cbc86ed01baad275aca4c52bbf2cca2c07001d891f4d61d32f7a7338cf31ab930aee38111037aedaaead882086f040f096e9f4387492172662742224152e57999a7d4876cc37c3afd575386e1023127ae453a8673c1c0a8b9931dda3f2b2019d92d8d858429fb58417019a1f98a1696076cede3c4164bca7d8855f770115c1eaec69d65641aeca3a50b7d3811f8e8d9a4504463b321ab0e7461f1015135d43f8c84d9574fb0aa26729d694895841848682856c39ed072e99e712e2415c7b924f1ec4f2c7d73ab8782d211017a3ac6a9a3330ee9d04c79b3cb97e40e3701f0adeb310c97f484bc83f71145075a1ec31e0c04c73d314aca42bf34d36f542ec04584445072199982d25384630c89823e6209bc3b135b4d7538debced8b77e22bb3a2db7b43e12fb630aff2d1d5b6a500ba14a7b8a574aed8c4be58e77e47052163facdeee94fd2996cd652bc0753a44045842f445b490a4d7f47dc324e2e1d1dc76da66e09d507a25db0ba4b54d9c9935a9b9496d30ab8a1d2d24a858d75e54693f1e6e6a4e9607e6007abb1c5a637e5d13ee9563543741d6d0f84c73d3e6a67a1eface65f6cc39fd6ba003028ad54affa878822061d58e8b9591299cbc16d928ee7182c6369e4d4c1e362501cb0453ca16251ee4b0b76f779d4534d86f6cf31693f72e57fc66f4784537132defc1903dd15c872374170b5bc60a113e7d72898ae961b660c5772578a5450dbf6cb0a2f7ed649d7f8a1273925dad1649f25158d7bce9384f9e059be62df239e6137d87caeca9670660622d0ed99654ae0f5677c59802d22a3efb0aed3dd154bda685cf6451bfdae0a6dc2db4ff63041b3a0d51b5e96dfc4fe626eaedaa9d587d34e98717aa096b2e9e065aa179008966816e39e1685c9f109ea2351ce63f02eaf0519504e34c7d67c67a7ac5afa6d7fc52150d5284e6833da3431fe2e2f403173b2a80d025b1314ff9b55457e93a543625ffdc274a3492b7717b4d1b479c587cfa73427db491bc8e7796963b668fc071607ccd5d6b55d1df9ac347a83c8e0f1f9408ec9f1c8fe80aec8049a61c1bb0ba72f2a0dab9e5865eaec0de15ef28df634c0b36f1fd2671bbba0f6fd4de9dd49c5f878abf6852065fc8ebe0b5bae76b3184ee0949f65ef0b81889112f7db1a173383be8cfe8c070159ae8eed9f20e87fb2e4d0ee4302b14b3b1e46a0ece9c64eb55e13bfdec836f53006cdbc50594d3a1befc4d689b5fe8773826232aa41365ba0d2c67df6cb34dd09ed470c6ac4743eeb50f8c3573bcfae3919f641e8100fbcf0eca4ed9cad0f0a352a75e34beb35df09d84f750f388e05e48f943c4ed082ffaf8c6e8709ab1a68e7c4d05dce2f7b2ec861bf78cd8f6a3416c3e60c03f2265cf3f8bea297e0dcd7420d0d64fb97f08f564967277ef9831368321a863f0ac3a55ffedcb2165b4750f8b172d7af39870eff2e5eaddd93f02e06ce76e99a2568375f429c04346760c4941a4c71309a6f4999d5cc257db302a9cfd103faec3dae78114e1c22bf4ead2ec995e774765550943ed94905bc26810514382b21ffa3fb3d3c818f9057793839a8d919df4da331956a3784146922adb6b3fcfccb5920db928d0a8254f1f3fb7915eee2ed4b81ce6b0726882a9554cee8890ef1df678a690fcae82f1e752cdb2f1e319bfe5b7482b4d89345eae2fa674b1dc6b4b716eb88117c4e75ca01a1bff0d2ac2347ba3e0125020ee350619595f38a663fbd01a45c4501292d1631eea7e69b3aa40c48a0599a568147792240cfc8c34a8a43198d79eb9b1e03d5193b2044fa2f53f277ce4159038e8507080acac58ccfb544bca515f92ffd36ab9968878eda37c7590dfb0496b97b4cf1b6e6c36dd02b49815957ca3ab65707e1d446393f9ef756fceb40bc07f9d3efa3d0748028cf7b99ce8abda24dab926e9be5d96b9811a0f59254572151d080d370bf2ddba0b007f2eba28984f984af4bbaf3638facbb6a4967180f65de5c75cb5526d6e7b55cffd90c9fc8dc5feea08c32a831cc0e00fa389744698f936016356559671ef588ec353116bf18d8fecfeb59bc7f199c32605e63ea1e763ab9911fd1622931049cd6a8082b77c4c5a109eae09a93d0ff70d7022daaef2cb74fa967560656f4f7dbc925ae627cfdcc1c1b727c87e184895b3ef150af52c58065914d5ff6470ff3277e036bf93cd1c393324176c7b9861d03746a5b8678c986b3994e674d4744dc64b4c6aa577675314100423f1e3dd0fea6e1ba31449545ebb6ff55b075340ccab4836539db6864055599ad7c10ac1ebd98dfcdce1a5201bac4754395943b736916d37a86c3304cbcc5becbf8953d23bc064a1e434d91f387185624961662fc4e926522d5f8d78dabc765729ffcdd1749f1e8f8de7c35b22f0c56fa649d19d986062c95877910d9e1b0b5bbc7f396a03d5ef30a7898b23e0d375855893cd773c6aac3f57bd5a5bf3559d4fb8400b4a3477c4f676d244e07f1ce1231e36b61fd0b24dd6103be6b44b404d3241b187d1e881382f95b189587310f101357ec69a165ada6cbce27bbec9521e230ed4999e7d34dc99da8011290af718261476a425a45b7e36f31f61cdcfca2348dc1c2816ed95685804d23689452f93c1c415a9a1e403621f9e5e7c17b13a4f72850253f7247df7da78cafcc588aa542185b3a26e2072ce88bc96812e34113a70f87e882ee63703d8178f17fa6c954d4666668e45b33fe2e1f935c01f112bfda37849c5d4dc9a006e66af2761beed2c5f8f9b01b40e2f9e1887abdb770d9788b4040f09e7c59cbfdb2eda36e3a3955821d6803bf2a5559781551621bdc4b61c60df14c218142f13c4364b1d804ee104b7fe253bc84e395bb2c9e03d865825c112a3439c7555a341a1e82102e6f5b7f50cf076a12bdc77dadcee26508ea559a7d1723805c6fb76d21ca3292035cbb0dc4308dbce65c5f7aa0d71ba524d04408be4b694f0f645fefa9b444780473ca30afb36091debfebdfc14f1d5f82cc43b165286b6b5e63a9bc9f2f271bed366bd835ca44829710327661e45ec0b44905b6a441ad5cace946cf510d4366ff4ce46a719834bfedbe7ac4587088d8f18ea96978015b3cb436708de4e9b717f0a9e7f6a7283d480c1818ecec40501c93c84c98ef5ab58e484c95ff35b728c41fc260b820c83aba305b9dda0845c40ef3b991d4e0c86f97efb51b918b6e8b7c5ceb10ba955836ce79abe55679c0e0f7ce21a5de3f118f0f88c9f9e27d6cef5c560d849919ecfbf254c138bd957f1b8f272da4218be83af7afe3ca7e15729c879651311054dade0c63023113af2a98393c00b18a24ed5d9f0d0a86f799f6ffdc55dd99732fd427f07b73dffe0c8a6031274d2591bb10e89ebb58385076ce70b2d31eda86ca43f6aa475b26e53ecc3582b3d4db67fdd9192ca346993af286ccdfa0218ee84587ecc3a1e6056aee0d5e64b5f7604bc9ac979efaa4be91b75ee16bacca62799f05f9c6a550f3f1f9e92beab92045e239f058d6d882a5d50528b3695d96cbb0ee66e52728d29343468c6e36e32debecb89eace45641174de448c3451313041b123c005b7665c1453da8e86244c8d81723bfdb84fe0716509fb41d5244929502764dbf8555da576c16ac59971e14f699c54c86654392dc1b539672af22d3e5cd717e67c145a82f0117c31eef43695e9350c46bd4924ed75901371553ef5bb5e958413b9611f09623052921a777667a6925f42d5d54c25d4a29aae791ce3072a4595eeeeb52da18a79b360a87e7d4f48aabbdc6860fce0aff34742410c268ad3b69ec527400d34b1234d267ba55ca17c83164d29e4e4e86a2d006badfbf529783f2fd40721695615a31ac27d728cd59d6a8c02bee0943a3746ba7b41ead9aaf7a72352e5c81d4bfbff37af3f687abc707e4d89df1e6d6851075587fa7fe8694b9628d8a7eb31dc3a4f9b19ec76bf894ae5f55abb64128db9c63d242e30b4e26e39f26593756e7dcd8af7362ef8c0e0de090fabe494323a89ecadbac194bc4663f82341827497abbaa8cd1a49364421e780a54ecb43134c589dfbab48e58fe7ca5ea53df15c1c1583d7738b262a1bbe9af6ca4c1df5a6ee52405c4dd2ed441178c71d493ed13f27ac03554ddeae69d6b6cc42f23fad1be11bc033304e0e9ba98fa53811e7341e7ff2d2358b16a6ef7436ab2dafc1f79ec591138c6c4479791ecd75bc1251cd2d80c18a29200ec78656a5b88f55112a0621d28ffe6cef0a902fc397f3764bf7a70770e42184e0a0d5ce22dc0ee0901b985ec4e098b7e5cf630f4d3b1d3d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"511239fa19e15fc704da8df251ffa6b4"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
