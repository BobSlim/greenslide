<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c623a8a55b702ce94e30d0e5fc9d8de4f33d0e5f9dd83af04886de21bfc217eeed8bf888baec74498b90177bb0ffdb5264282b849ead0f82e067c4c5fc5b6bfcbdaffd8aa46e9e2142e49a263d3f19df5b430eb4122d2f761be052c75ce77760a68c9b1eee310f11219331c2f96d0d7535fbd961107afdb17ffeff956d2aa802d40f1e174820615366b34db105e715be04906925a6e7a9f8340b33553c630cc0b28e1116ab54ccf6b08dc9c8cd1e06dfbb285b66fe0558a2021048f5ffbed57ee276fb46eb2b1d849317e18c17aacdacf515764eeed0b8d5ebf14a0e9089f277e2cf08dc8ddcda7777e1abb607c56a01f189f0d2c1ae5a44f353dcd07df872158ce4aebd85913625c9e0324b3e8f46b78fd336d9892f24be5e90a2ae56032c58cee8c48f490dbe748554fa21cb76305701bf2feb610b681b5f597185393a4dabc0b2930f3a96962e9e9a51d2302cd3d5d5857ec58f29ca94eec67bff1344b62b7137e3de133cd70ca29a824edd84cb4d0d7c46f029d9c2a7114fc15a4422f03f081f870ba7793ddd1f4cf890dcd752d53cc2c36c559911a3ee20d4526a353b5fc0dc0678da5bb968c2a7ea9ab7ae4df2ff1ad9fb1170c1649f71605f85a18f7343be6238af3d3cfa7072190b77ad423d30307f740e0b83f4b76f899cd061f75a746a77c30376269483756c5371b87f6af6cf7f3fc0dbf2afe024f5c77111c02748b076b60781fb7e1d6e8490f19ceb7c829effe86a9cba397d3830142cfcdd22a002f7892d0cbc467c5db6ef9a752de81fb6afaa51f4dec00c374bcd2d4aa1fca25353953f215f0ddcbb36eabfd11a64e0d704bd4e5ee27211380c8f8d41311007ec8a7c9df0a22c2e7b57261a51e7c65068bdccdd0476a9da5b7619a8ddc20fbd4c194a07454d658ea8f198d7871fbd517b7784b416bcd37472246c4e3cd02cf72310e39ae97c32d2b5531996f028da316d12216952e7c6acb323e5cbc143a0bfb172f946bf84afc740bd156816e99540da5219fd86c2fd850c627c670a0a929fa043b4f8cdca7c0210e49b5c31a1c4187225fd8dce4c88afb954f59f2b6578b977444fa648c0670fd15e26523ba99aa6bcb145b9f0e5a4875d7c94649826483a13adc1570f11e56fa83c346d0a0da5c5284900ea638dec3b0d79469c691db36fb303809860f5cc041a8654bf06952041e769db43b277f7b41253f7e7861e18f337e1988672940b607f8584394c692a27157a3ac21ae3ef2cb8d4bed0f1bc2c611c3d735c6fd38f352b2916dbfecc2f4412bd7a58733d32160d173dc6634d5409a10d40ed6e6d0b82ebe478a4aad3f7e304e236a6ada4f5d2633f193d44e7a1179ce36ddb932f7cf1685644f3cb637fc8231b475ae2a38d1fcf5bff47cf19da48bd58930ce52887d921470c9452cec87471971fdaf19f96e1a212550031b87c00386e6ef59eceaf8b9cee61d26e2413af2303f0cef8099c9349ffbb868fb3212bd7c55cc732291b810db84feb6df37fcab8c39c88b77325b69dd51d36b3d600bc28a960e6aa7099835e66ff7a5921345bee467fb3470bccaa9f2fbd3667d8bf91671e986e6de1f64807614b511ddd9f0deb7cfa74e69e89e3cc899c29b3a3aab407da38c55654757e5f2caa35a54f41d7b689b144fb91428ecc8789004b1cc09167562a765d0a6b2a44d7ef1e142b6ca00cec87c143f16a7d06584f8e37a2e9a9088e4b0c8b694c29e4cbb9b292b7aacbc9a49308927172da52e20f8068f166ee181fe1575fa28d3022bc03f447f3277f2f3992c0f5e931e05a1c2b4e82049bf67413b91dbf25661c50d97a8fb5d07b42b95798a5f149b1d53835149b01baf30c1cdd55add20390e758afe15fdedeaf9dbbaad7c1bd5b54c0e960510916b85d97f5f27e500fdbdef5bd2fd4e34ee6e5916f1bac589b75f450a07312f8da4bcef7abbedc0876295c718b3102c7dc5e54b759feea67a11722bb9e06a305c4e9542949b329cdfe1679c9125df1345efd9fe5ebe24467a23492807c71a8c6df5ab73adb9a6cefb04837b5a3d75618ac671857f1f000fb3f8be5a45c00388b6ae3d962a23239cfac5552ae9b23c1b617a4b2f430c9e3e1d5ab2acbef83d4bade95922677513c202e654fbafd2799fc841d23c5e0baccd83516d2b754da66149b4e1d327e04213f57788f720e189a8d6f88779e2fcc5449526ffa3dee23bd70bcc10447847c431465e143f600691eab8f0898b5a397bfe067d46f934506004b0e6b0a51f732e0f3c6d1121fea7228e6e12a7f6eb4f9797f966ad8dd2aa6a27db43ef0c213832dc11d9dcea4e459f0f51131f7f33bf6363cf409162e8a1fd7030aab722f15a03dde6905c55e057c02223ad1d9e5cc948dfd46917354a3213c6f69b7a76963b8aaadf2f067b49a60bf49b4b74620a30e0c6e5baf628bd7b63ba3f657b4d48730187ad806309fc5845c4bba873cec57e631b48bdabf51c8477e715ee5ed362e4b3eeb1bd661f6028e8427f86102207ac5e2d04522cdb1aef26a361256a87f8e59423a0fcc78bfc4c5613ab10c79e281d6e736b5c7f00a46946f559f3f59e197f7ae4e06aeb66b5f99f832bda298ad54504fe92e8b1a3c77b19b3a2dafa1282e63297f21f1a51dc13dcea71e8d31cc04eac8d7393e526b1063320cef33034077cdf6d1803fa8ac38da8c2689e36fcf75eb7afc9ee9ce6ca9a8cb748badd8f4893dc611d99424e5381cd7a8b35dcf1d1e2e1364ff7a5218595c04aaf69fd1529fc3817fabfeab97b8a454d7cd0acf33d2541482b9142478adc24cff7b769262a36869bcd5d0cf85994eb49c62350397001f545914ecbe75729842bdfc1c3a8b38ed665bd3bf142c10483a5200a19a62ba6b2421ec551fc790207fd38ef720fedf485e9acb68d167df6db17e032ba3a411ddca3269fde6dd6486a63e19c7c69fdec621eb588e89260697cf07cc186a846a828811891565b75cf40de5e0d0e52bd7600cbff1d6ead0eb4da48c76e15e0ce2db14a3890d2623d4010e2f6f527bfa6f17b3788ac394bc91bbe0f3bd91395f57ff92750fe3053b4b2b1daf351056074fcd1ac79a8653ebab9ab2cbadce5dadd63b56f4226caf5a60dedfb3197692925ccaae8f55f70c4896a503d9c6d5d92337416a1fb8cd56c39295a0bc860dd0d4472a4233e31ff19b68aeacc134578cdb4bf23785410f4b753924b20c72a7cccebd4ad90ad2af9ea9094d1afc1ff1d88fff9bded2af52a916b793b7a9a2546d959d455a3db8d08f2ddc702647ee6c6ee5f3ea44a5880b0380ae57cf8d4635a865c41e89e150fd55ce9b6bb737e8cf0a535ec23eef053154454e87b3307c1a808a046b1d0a1d695ea44a23bd304b5f65a0a2b182caaba6f366a80887d11fd5b696703fdf31f6cc2bbfb7d06343b707eaf529d3894cc99e5bc841f62f540b5531edd36607fd24b1e84276144b7a5771a0b9f92336ea72e610d1ec520c3b02e8aec605dc53d73239f2a792cd38e8f5669bba6bef8854d3e5ab2aa7944c72479b3592679c59fe72d7cad58439d527ce4536c730c5da9b052014df27b518cf3c91c9eb7433702cc1970e98ca948ef3389e3a339f7278a8a986f30cf13af492c60105aa6e9b5d84b058ac46c89944bfa5c94f1d456b1923fe3b399fa40aa10d15740769b268bcd60a2c2cc927946610d312547cfc522ddfcee80e46f1ab233ae74adca81065d3223cc72dc3ad4bbe41aad0ce7e92b3e51c9ea2a262d3d1779a749be658709484a58a61a4779c2583b0e5093b58f8aa65b7b9c573ae9a0e94629fbb3fae32aa2e975f010c0955d9477d3c1bfb8e18bbe9b0c99177f71d7f83c5d8578c9dbca90bd11e284d9fdda12b39ee4a2fb449b583fa5f3fb4ae4ed2ba8c2cda7ece3a3390e2adc84c1501201c0d0a9cc0c8a823cf7608b9b34dfff5c95419748be0a68dba2691a241edf6a763feed963ab6f58ebd3b016ce1d56f734cb11c25e8e876dfd80a75dba6c3da6abfa6df2f3c2d4d8765fc84a7ba56ebfae5e035df016459f2b3069207681a8e3b9bf757b3df1ad250492d73c099b563407b4087b58501536154d1129653090c1ba6a626422fb82c6e8df834866dd4b75e01e1f6bc66af989e93ed128950aa0892e25fbe20b7e65a111741613585ffd21ff767c287a9d8bf7e611f452c5657959b0154cfd40371bae1da6d4d94a1d27e37b2f097f44209a83662be56de2c30d66da924ab7bf54497e10fb63eae651167639a660b335cc7d01aaba4d862124db8fc6917804a5d133fa59db588bd0dd466cfc40cb762a5173361a50255302272244314c57482f2e8875d48c59f019abb234e14c76fa4f7936e677a2487208d95b93c924b4699896e6ac12a2f2fc341183308f7a0098faa9180029753a477533fb83f95c69895d2dd00fbd962dd876fbd631db9a04066b3678cab28f0fe699df20798f153fe0be251d8c141426fa975e4e01c06e712993742111ca97b86d33cf45f4243bb9dc4c2481e41dae8b9fbac19fc6029f400f165f0cc124da7523a5f326b71e0482f9864af7c4f63c516b23531e5351d1eb3d475fdcf542d1bae1550da1f6ce09abb0038d4f9a449837120d30d5deef5ceef7c3888c6d9359d583db86af9471f41ebd5413d7a102c07d7748b2f58ae81da5bca75dbc6be035c5055f56ba0bcef9741f6b17ee6bd86bd740590fa154e9434e679815226c883c3b677855e1fe29f2fd0898ee3e35424c81f8cdd916d216f6cc079fa40b3f868c6110a3068c1c214987d37f6153f600b151b15fcbc1010b193b011b0e01fd0173da9c10bcf387a170c6f73246f23a4245ab5927b45eed6914dc463e84097bee393024afe127c84e98e822916c280ffe1acb35f815bb8c8ea5ff31c39841005dd02fdc9f416ffd71e0ae6f1c2ac659d475fa695c6db426b8068ea089dfbff27d7b7b8c4e79e13c2419fbe7615db4ffd62e0e54a9f24c39db0c53a4bf3635889c1f9408ed53b15919ce121f83b634bf0e2b37f5314e02eba1374f300719dbb01dd755c5b6422de5f61067091acb9fafb095e1702080e781976ee2d5bd6299a412b40de59bf4ca1d93385efd2c227d9d4d912af1f663c23030f0d780901b6e245f0a33d1ab9e0eb4a0caf6ba7f8f2641f3b2cdd236b2a6bccb3bf8a796b162e5f5423afc6161b9efb0d03b4d9d0e1638e64dd035b5849f95297c9fea155decf35c4cac8ee1edd9ce3e435bbb4fd0067521114187fea9f15511f9d70915c151400e59d68c1d32c435a9577ffef7b1f2e2fca829eebcb24f22be9d03e88a07e1dc06cc05e94fd12ec4849fb1d92b0589e777e0e7b36e14243965c6dc43e402168f221b4b23499e580da04c89eea046e13ed8bc062206fcb759ffc6093da1e310168b7132879e3b6e3f6e589d826ee1d61eb55504b185783d60adf1d11ff3ae786c788fcade8c8cfae490c7c8111b5b46289ec26b91bf2a1be1737d6569703e958bd29e1311e2e0360b3336cb91cab4cd8db4a18906b999299610453bc35c2fa45cf52d223d94da339aad6a645b665d26d576c8ba708b562ea475f9b9c1d0e3d4376393be012e5c6273601d65f2dafe7d936bb88ffea2782de71d75e04c8b841f736279c4d801caefc8839b21bcfbbb985c44105863275fe459103e7536252170dd46d381b94554925b706f8e766419d57dfaf7ec536919b885cbc4466047c6c60f63c1e35b69137abdcdc7db94279eb970ff361b975ce515f954ca1d969e8ad833cc5d4c1646cc03020351fa0dd915822b37d0f92f7cd2387c4293a85eae70ec16017e48fefd2804f471e84c2f7b5b5a803daa88d5ccd4ba80ccc34da822e750479fb9004c3a2877ece8ab9487a2854912461a0fc7be1d0e059d3a083347a00c471ba74f23358a2deb9885f289066a3b367fa56aaf580e9bf15bbf6d670ab3cad3da068a9db778ec38b1bb8ff21eba3370eb6d154999c8d8807e64d63031aaaba471c29619ef453a6f30626eec45a73bd4a3b2464475c4068187842ad93b3848f667027e8691150a2d0a5d49b203feb0fa9fafb79a3a4210769e31b53fa83fd9571969ec3a9b9a5c2a06a10e01478ca8ef693effeed4ce4ca8477e645067be780d1bdbe38b448fa8be0b64b9dd55e86c977b4bcb6fe5e805eba2965d24a7eb27863adf361b28a363f6903363562b8bc66e222854dad7347bd03b8858d34ada8db4d2f0dbdf7ee9044551dbd7b77320af345d8240031b41740857015fda7af90da9b76fe15d0dab338065628e0444327170440993aca70db6f4f584a966e099dc0d6fc483fd7049b9dc4c8432dc169e4ba55c0c2d0d79b7b9805b790fe5c919b64223943e33b5c19b823babbe9ef09e6d1032943df0e59dc763b27f056bdc34a675fcb8fa1eba070b46cd5a80ea2ac5b821240c87ac8ee5ba7fde6eaceeb4c2399139dee33c53d52e4c84df30dbef950bcf36e12b3810b6d6b775a381c1cb7d2481db2ec34bf8134fec5e4cecdca1109b1f9c5a302d0b0ae23797bac16808b039c1850d732c432e5fadadfad9b6131eed7f68781cac5858e1b229d7bd2b57225b5c1b4de14594c80b4efe8290f04091d61970284e3532ab2102e9589cf11aeb99c67b8b2b953c21e86f67a0b68d0102ee6624d56c9023276e3a654fdd9fee365b5ed05ddcb5e530942ed3f0673e60779d96d56f11510710fad363119f0563c055776806b54c55e0f2f16050dd52671acce303db0714dafe96343cf836816be614b0e505af2659f2677325f061d2d41e602299f55bba72925811e018afc3c0c56ceb8ef8df0616658a5ab85458fe12331664098e3d3622bd08df2e594ccdf3f1c2ddbfc7acf92efb241af52014f6e7003c8e3a035ec67f0e1fab7a9f5e8997ff6950c3cf52272ef8b26b6a8167cb7648da469e0c63cefa25a28519d1b4a3bbe2f397c28e239092e5e227e6a71dc97905eb752d347df77ff70cf36cadbc6f12d10132c7d34c0daab72d481580faf20ea6013cc7252decb2a6e83369965ce5ab9d39da9108980b0f314ce9a40396b4effe6a77b30e153c5f029e37208e4bc1d9004708a3f8eec774fb7ec26b07e0490a33dfb7c0a7c8861cfe83a881e3ccc34432ee90240521ae99f1e9149da5e5a7cbc48a241569d4bbe64bb8d4a6aaf55b945fb68811d12fec0ec12ce20d99ca3c1d21183cf8af8cccb0ed6dd731927cfbf01993bc98222adf603a535ea80b076b445f0c46cb70efeb9ace4986765bdf4ee188978a61b6bc85f62268aed9d50af1f9eb1e832dc86005a4efb6c75d3dacc82700f86e80ae503e64f720d67c46f8b18a635293ee049bdb216605f5187bc1da22194ae8d97aaf250ba4aaf091400b29a87706c7b619e22830da1fd686f1b8a71b678046b87fea14870e849d26025199c58320b80126834459eba4c22b9acd1fd5bfef56411a0fbd4af56f059f628c44317c56265ee4aeebb968ff431e981e93e368afbafb60a18f3f77a95efa1fe4ea363da94638e88c9080a5d999ebc08f1a0717439be75f4c0a5bb9d8859363fe1f5bc3acd1a881c3e32a1842f2787bd2c4421a0d3b0ae555a5a7590298fd8b7bded845763e8d1dbcd4a680a3a1c0b7331c9ee926d1caa78874ddbd38e274abdf540a59fcc59748930c328a88b450e355b48ff68d4fe2e2fabcc21f4e47a8a5f8d35040c37fcc25ac09aa47ffdb5bc3025f3be1c1ef2e36f1d41afd63a60ea8e8b0b24169e0dabf5151ef972a3333fa5287096818d20520ea5c4c7a5f5ccc7dafe15a779ee343a15f8abfcb237288b88ad6f860ccb365e42fc23da1f4e1119ec34da8000436348ad1d2008125491b9ea8132b0955e918c38d36fb476c1ed6d242ea2dc421d58e727d4e875ff1e0f432bce7d37b5b2475cef6d5ece0c57518920b050336eabecbb97e7c1eaf98b714a3dda6e84983363355ee61695a67bdbcba3b199033d3543eca90a4d72c5e0b589a64e09ff34285d97de6cbc1b5d6ec3ae3fa4eda3d9c656838da1d9614db968b0551b26493cd763f7cdbfd79d9159b4c93a8cef1bceb5bea1a19ce09697c1324e99b4a8adee8915800c404a68ea37366b36a7a5ec94ae3f955b794e0380f471120177d728eaef5c6c4ade3a2879eea3b740117bc26b28e0c9bf492f4a43b524305de94c8e2504b2ffa819d0063599c8684baeb4d7353cf96ecf0456ec714fc1efd819e38df3fb9edbe8df321f77830b56f8970c5cc7a869cbbee24fd0c771fe23fb38a3078f1283684047cb54d4017d54affc42ccfbe714d592893591234ae4e7c64d76a081679c3a75aff15b2c2f3275d6bac443b3ff7cddc1eac69831ae6b096b03794e6500a4b81ece8b0f32a1d9735723cff1f7d3592c7523fe9392257c438729ac4e51725d088b566ab98f8a54dcdedffef616d6272fc9a0e58a5d9734fa45b3bb703dac6a28495c886bec4e550342c439fac3a717c964f8a908bbacfc1eac16f87d9548d3edbcb0da3e6932172ad2b6cdd879626711a95badfc5d0aab54370bd45bb870a188b85a7eff45083b94532b765afed62a6c04ddda26d538d459d3da83bfd3d0102376626458da2e2c635c0efb73c8d962164ff3e957232362306deed26232ec37975d03181fdf8f252b06f5f8334bd620c7c52944ca6c64907c73cc2aed6c95827e9fc1911d7f92d445d406696f7a86fad7c40fb0b146e2d77e9344f5efe8309c2d4c034d4e37b7c9cfcfbc4ac8c9f2a0661e3b70d772d7bc5fbbf884e568b6729756ce8120a9084577d3377d26d0a86c9eee856c857102e032c834e482c151a184935d2bd3789c90be27605bc736c1d9380126b468406e032a8b41260be2732354755b195271a36772c78336dccc54b4fb9a19fb56a5074bdf763eb856a3bba9d99a862aa87f4b5b6ca9b26c1d6349b6201bd1440c50c1f7ef371e5ebea0a838ef6ca5c756ec220b53a8cefd9176cc52594f764332bc6c91d68abb606840a94c75e6c7e34d35c2b586db3b9508bbd29614cbb995ed2b04895f7cc3ffb23b0bf15902cbe06da273e44e41945f227ae022080fc0ceb07359d7e38ec79dc3e2f0790f2fe1f7b5adea3b79e5b5520d7bd32a87c70420591bdb44884ed2f71c29f6849c7c1428c5fcf4f013c92f4faa8479bb98fc1f4b4aaa3cc576a6a28b4fa88da8cefb04f6f3e486f8df62b45b9dc28cea363d6807874a5e0f0914354791b9d268a4886755be57b8d0da0c2fcd0c19f0fc80d1b45f8570c081873a0a6bc087d276ae27579341f78c751de26c44bac1ec8557b5a310040f7f21e8f68f528257dd59d56fceb50b4159b1bf49c95ef3db91d6352ef75ae52f46f3c6ddcaed9c248bbe5a020a227cdb7e2336f4ca65c1ef30ef98850298584741c0767e0a7df70fbc2ad0952e78187466ae9373626093b0c349def891429eca65c717d889cbdacf3ed0fd4989d7689040b127fe0dbd7e0fa26e0047231949518140730b0ec16f28120d2bee68eebd14c8e03507685ca8d66cfed5b7070f96c2c2667551919b300a932109bd69535dace53322ca26f1cc24cc910a36e51eb160299b9e8870c74329161ca078d51ebf1f33722ac013628c62fb0c2b1a039b644ae7db9f855079688ed34f58d564871d0f0d95b4e04346381797a436e1df707ba36acb8af1259808d24d293619b0ea31c93be2c017054e9fc8912aea2557d9dcc2fa72ffd015e3f59a87844ed0966e26695e32db905b012f617c9afb7437d37912a277039f9f03e00cb8dce160c9c85aa241af779ad9356fede7a58846cd45405978a9e3559fe3c3d4cd3551fa8044236a8096b54c8c9b379650b4f33e20f70225dd6aa267f1947a87cae492256d7f4c2d81948bfcd1fb3c7eb66efba427bb48c7e9a2a41b34753c45822fd7d5bf556041d76c46876e2830d13765ed3728a3f26fd618471c7c06547259a4a9bdd89d750d564cb060078f29bb5ad13bf60753650723df99bed9d8f8f8d70dc84996098615d828645c9d535bd7e8bf0421eab46ec1d164b043c5a7c1a2b47081fe367f11b8fcca7cb38188b7c71b51b4559d36df801f492c57fab57ab341c113fc500fcf132e3981a7e9355737a3c979d2df1e24ece592e92b2dcd300ebb73abf465a2f466a816a4c9acbdfc1a15441f87abf622e86b4231ea25c0b791da449ac1e83479c29c52fbf1c05c7f3d11475ac56f5b8e36cab38cac5259c60d8adf5bbfae1abb8bab08f926ffbcec7c00ec495f17810ddd3e1931c213cec6e651c929796519965dcbf76a363a28c366b52685c754f7c844f56be8389deef45a05ddf040f55727d0eccfe8b998282e010c8d0669c437ad6a68081991ef64d9086442d0a1fad787e271caa546678edc0ff8c0e4cc780a0598c2ed023226cbc39a91d3ecfd2f0b5d85ea8b794454fa5f739f775d25b84f945f2f94a59433fe6d8fcf38a6288cf7be63239fa3fbf37a1581affe92bdb12f908e73f20c492e007c885c066c65a4a7b645e95a87a475a6b4b71c173109bf1cdead94a68af769873c97590c4883686941950c8b4d24ec1b672df911fd557ba947ba437da8f84d1ea8ce4cd9749fe87550cb5d7250a8b0e744dea011623faa7189d51cca059b3dab6527b9a6bb17daa448c172879b4af021cfc9a9f0fe2e26f177d1fb2b5b9285284b7a66da3204a931afa524f6f8bfdafbf35077b9098c47f2a41b7146518bda316b37cec974eb3f54606cf8f7281c34c9d81ce45c8726c801cbd1b66a8b395c725c6615a9649feb5993a95782ed20de8258659e05d9025d221f9da00020e5414b16f823fcd7c6fe19af9e9395c825620e5c0ab00831be2de13d26e639ad057617c3cbc3aa16f700f453c07296aa150a0a3d75a74f05a21b89bead2cf7b710fc05e005c758b45c87f35558f401e1a4341b26f8097dcecaa103a0bdd3651bac065053388cd26fd3794a4c2b2c1284c9d47436bf5f721bd14b958646a79cf40315f26ce2493d2224d0be5a62b934d3b45e449079d9fede1abe3566aa0cc2d80a6f6bb112f3a6fe53e0c03e5c2990abbf0761b6e18b7cd727e12b076b2bd53176265b12213f9fb21cf87c01b0907fdd859e39ab08f1e4440ea7f2ab762a0816b201a11cc4db2dc197e366eeb4f9586406b72970498784d5ade6441ac27b2f006f921935","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"b13c9061ba7b80b05aa6f57bab667da7"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
