<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d08290b995ba8578ec435e951ed0dd638dbfac7e7a94b322751ac22b04bb5faee0fb073004f9faac0c808f702c769b0ed4cf3a273cbee6bd32db935641591eb049480182b717917e0a2688fb8d631e6ff1637dadec9f096a787cb83f1dd43efc2919d14a16fcbd9c2485722e559bd26d6eb8d70e988e7c758c6ae25eff666520eb9a2607540bb59c00e9974e83bbdcb50b6a9c0d0ca4ad0457c2813e922c01b0fee4a439088c301c5ba1d4b644b12164f5cd42d141113b878445cfe96603255fbbace6fb5455fdeb59c815fdf4cc6fd86d49e6e41b55c8228cd0c88ea8feafc2037c2948145f0b5638fb88d6b51a3e6c386852d266083e38160a04ebb97ef787052a46ff6cc85a662ca25c990845c040fb6eb7e47545e33db11f61a58c0a66ec58461949cf966706fa29f65fef5cf013ed3448f1b10c1b89fb7a1e31f6cc13421742c5891eb6ee655de151bf860d17c5029e2a844a9f06f4ea1b70d2d38c1903ddb5c2526b6ae691693eafd9931f8a8effc7ced381eb242d47a1fd9c6bd524c5eb2a88dcc1cb813be536bb1dba14f40389273fffb20ea3b8833842c5cab910314d9d81214d55fe0d3d1a81359fd3ade853167788dab4f58b5d288836ddb552efc9aa98447c5471e4a11538154d61b6a73a502abfcd234e1e414012d3d276934f6c99a6b3e7e415435c216a6de4056aac120a029331503dfb5f2c6a94bf861ca30a689901092f1be7fa364faabdf63e70e71567b7bce948d68703141fe1b24a577701f98667c2f47563e879e98d36abc5feaed2f675b9821754e5afa9edab0c3ca82d24cbf19dec6476ec6c7388837a213c35f8b01169955fb415c9187e7046f3a468a0bef00c3811832d5979d87c4408e54353884d1d1a6ea63e812243d24f6c1529ff9fe91f26ee785be81e6255874bde5f063b0fd9b45a8bbf40a1c31b1bd779c47dcc8a7586bd4bbde3f49f8fc51344de48a9830385ce1ee3e44e91334f71fadda998d8d4329919cff8babffb785314ad343965436ed0284d7872a14d6c97ca65d17ac69e59b881bad34a7fc6a9f5c8a13b08fe7e9b2f9fb377f23d0b50fe313ff61bb15cca545d98df82199b6d11ef21750eff5a961864e2e5776f9f0047f2a220539fc55e4c123c318cd68aa00984a57234b60b39e4113b353d1b208d2c0e8945071490829c016a4a6bf3d6c5796be38aa68ec537b0ccf3fe2c5b54ad2d6dcffe2f0ac4d15bdf3abdf6c9375a30f38f0cf94aaba45504adddfcc6d546f35b63256e20ecbc07c212c418bff69be7365317d0bfda11acb80a70ea9ff9bec259d6686961860a8672d6fe62cdc4f86f802c6c56f37e721c23a1daf8ffc63d73afb49803b4902fcf70467abcd6699881d5030faffdc38210c4076977fac7a9de20670fb709f2cea965b7297751e2ce8ff0d2da2c7ef8a28db38e43a4a0d143390e71b95f85f7a4f00bbd442fffcb8990231a56affa4475767303682c8d9cebb2f68d1bc137c01ade3a1a9235d7a926083905b3f6014c8709476cbd25281a601aecefd8cde5bf1ddf4e283a1588e59bf7132a9cb9d5a86f71a927b1208e427323a5e2cf69167a7e0345ae677084d01e791f0fd353a4fda84b9e5bfb3bd6acb2fcbabe66388e1d7e95df6756be0b7407f78e1e02bd98ef7aceffad2cd54268c046e99785e7e948b31c98e507357b1ec280b5a62c0b3de8fafcb7a136a91ea3ed78bffbc2e7c28e2bcb71a93d251e1827f0cb226447df2f550c1d0d183b908de3045cfeb95b36692542662e98e0f769d22fc3a0782cbb1d06a412a8ba235c8720ae84847d1b83758e446a48adb13a3d5b1592ee5556eb3822a0a4eb1a96f9a884172d6d8045ce4c0972453caf2a69a74d97e7a2ab073ec021a51e8f71ed9da366e42f9dfff3e919bad302084538329c99c76cff2d0c48229f63a7e45de4484f7c921a790323e5ab2dc0f3884e07dcbd102d873420dd1e2ad887919b8fea4de4c8170c5b7a0b6775aadfa31db7e19ce9eaf41bd823ccd02879d6542a933a13f5726f3af2bfec55cbf58d485c94e4f97f5441ec6eb6d1b562f0b220387cfc9cf4526d229027efb1e155b1a7074516bb3b30a8865e398a3879dd47c38ffb8c95064a4b0efb7a34f655face8719c09f0781cde505b07ae358e4b8b2fa308c784050dd9a2340690461189265d030f669dc03a713107170f2d8cf24a914ebd1257b1a3f701a7ef3ef0b751e4dfbbaeaa80e3fcb974450da07a30a9920d4b5b84caef34c1411eb75079882d38f5fdf7c3958c965e5b3108d9d71168a0175648ecda38dd6151eebfee8efc6a5b25fcf21fab4fb6ec071b875c1f578d4f7b07314f6fc1da6ca50524858a6d2ee0a2797c41fd1d97caec61584fc7fcfa398ee5f986ee3dc2a906a157128912f955c363e85dc8da2d66b0862bc985bdd5ec29d2a20c47c31810ba9337599d90af0a0fe675e3dcc600d23cdb4e904c35c4781b70ef373567981dabdc9203cfd05e5afea8d688374e0b145f518567c33ecc84bd91f6e4d80449cf3c276574c58cd4b35a952477c77677639f77d1d447d6f4b6575e3c8c95fd23e43793c4c8a43ed4ed5d0728a8b1a96709f2d389eac1559d5d5e0f6f62bb3dd7c2a348fb54d8a8d1dc5cf9cd5d86204c30851172e883e3e96222ccfa63e9a040f383e95bcfe5271d5060dbb3357bc21c210104a6434c09a414e5771ce60d1507c837674e43211dbd7de85c0475d5fd4526fcf0adf99da2ee232409b1922697c5ef8c9b82405f1769ad45c38ec13d54540964a02ef1c6d870baf7cdebfb97ba268f40402afb709c9c8153c792a02ae2371967c9a62c629acf0c034b32286fbc4c6fac1c9145435663f9417bbf0efb5dc17b6591129cde87ebfa7b1f149933e98360524b80cf54437f1e07adc1f38ac39e669432fd820678988f272d034af724ff4b9a23ebbd391bc9eee1f30cee5079b1d902c615d4112af16eacb7d1de85bf358a7a77b305905598d63f8bf4d6b42dbd382f818430f59b63e5bce6e9fbfb82b024acd652eab796f0f1c744de17f7d5e696be49319991035ec00541af4d75b979f3068c9d3971ba6f8a22f98567644465f91cb0a72d25dae83a813af03d2ea19e5764766bb52934a6a044a9f5efa7a9d3ebf005cd96b3124d6c73451cf3b3e049dff5f79049dc47e26c9fada42015668d0433845ae74c1b5a1fc795fb2b5bdb5b61991618c8f365ead3b0d22e61bbf3cc81812bd4a7b86ab0fb9660def01b81915ad7bc8f028df095a11ed581d2b2768ca903b019391f1e37e40cf1b748a9f6443e60c0dfeb881ba629bdadfd6dd5fe889537b5318979e028a928e1155b662505aa40db68686f493e005f24099fb11cf61c584dc10460affd827734286164ee61bf08f866ad35e4c8a768989fb5f632344d1ff0f61f3d1bbe5087809e02b37c1be47eb38b352bf0fae7d8f68425adaa74f39ca39e1f5a3346208b6221fb2966b6fd2342eee37871d359cb77eada7bbcd70422cdf616a66d1043df783ec41481d55363fd26c06e9b5c3d91cabcb4d29ed0a465d72ca8dacc56a720ff6ae958cebdecc2edd2e400192251c19ea638ce86323d8a5bd9433a58c71676aae2cd4f00595af573dc967105844e1df7b0c65bf699e1e1b62b1d8bd330ec762cbd451bf8474b09246e9d01b215c4b3b13fb85fec354fe627db6a6ec29573527fa94506fe66b745bbbf3a8ccd0b897aaa7a557aa2a2ca1ec7b8a61f355552abd931ccc89e96437b897fe089abf8441475a249b4cfee4bcaf471dbac65ec51260a42f2db0c5d6375d9f9f0488c21933179496a717d1fb3f23690f26446674cc60ac98f7f3e6f796bc884c5a21d7ad6834526080edfc9cfbbc35484b03ff14f21ee4d5b9f93c16a6b35f28214f75ed36c53ee1ae875b5ff88eee1d8d8d30675a804d7687fe97167e9418c54981f9296ca96c739d0105d4b731d9fcac9d061eaee6442f1b8b07182cd67dc307729374fe188621aedca77481c32369db27c7393d0eb79dfb8d5c3bad2648f2450f8a5409bdb11b4314d596df43dab923be80488374cdf3ad855ad740237db99b2d14d789970cd60e3dcf2a3756fea1bfa4235424d2b1d82ce06d2b656f024468a493c9fdf5fbd5f2fd189b5169eeabea5cabab478be07837aca7aa7614039c1a0560a173ea511371e9d822a205340e2adc8ceb68d5d4dda61b0353a1570b644cb9d4b50dd23dc801d95b82146664ee03f3c7381a97001497079cbf8998e5e9904c376c3c09aacc98c0649be1c2ce2d237cd55208cb4143da77fdd2b68b736002ef915cc34e06ba258a0ac0ddcb7e697097c961df2b0c7be88710166df3eea2b4d59a7538f1cb58403671f6a1376c53a6fa2170090cd9672d3c90e0c31f8cc87f2e6affdbdf2eea9b766adb3615f8eb89532c6d2dbec1a22769bc61bb5783f9396f70107d3ec0a97ee97d4e6696f91760f062da8696808b0d07cc95c4be2973307f299adb537a5923da8a9795ed3e12722505054b43157016333fd4cfed003b371744463a3c4cd68eb1ec908837a19916f1b1893dd240f62d7d112c5e46aa3cafe158ddc17f31e7ed18d29a14ab7e92ac81947baf27f410ebe0edf44a5815815d74cdaa810ba46b64cca4fe619ea6e38dd5853e15a7d758ffef5855a2b318a21c5871b61e2a8e8185e4767dd407ee53569c010a833f679f38dac09c1cd60044d5b7dc9c1ac29a0098a52384dd6378100cc453ebaf9bca1f53ba54c33b8599fd75c7b5dab7e557d52a6a5ee3ebd588d8b22bcd93ca2fa0cc77251816f375f14ef2417c9f8c697231a54e4fbd013005c3499d2cfefe454d727b495cab0170dffec4f2aeea5b26c1b692cff8cfda0f2a165da2c1b439e54640c40b8c605994da34cc754f88bacd422860040b8106f051907a1f74b257f82599b08912472e23aed178b1d60f2e046bedaec2960ede4c64c950e5bfe287301d38afb38a3abbccaba886758ca5d876450a3525a4bd1e3579b33df39ff561e312f1ea96d6da7ac757aeb0c7aec45b6139d412ef83bb209f058ed6c34f579c3aa0ec717590663e7d5bae335c9403340d473e198f929877e39cd474076f9ec64be22ebb7bc36b15e2e6ec7bfdce5d060fc58386b701e11e75410fa476a8c381a2327c4dea0d4fb5ff6e503af332012a0febc6acf31cb306bea755ceeb63c1beccea7516a264f0ed2735c9bcbc3f3a49e235ca2438431578a143ef74f10f5d3c84b986a8d6e49b4423808a5e3a48a509f2b19544567fe1d092f8c5d599c413aa229e5d27ec803374a67160685493b84c552a72eb1f6f12c5d89193f11afd8f8d76a36fb7b48c94813f58e0d756eaf0076f0de423461b525e92fbddb265de0d3936e95a340abab1955a33c217600f245dba2958e631a11668df2b760b9c823e8a4103ff975aaca0190f64613be4d30b9f1147f0f04ded6f633ed13d65c2a3381fce6392bd637d6704f5a815041853e9034bd40ffc6fc3b6130128193f67af9ce87349353de1ce7a7e9d1dbab924e68f769c029206c9be5bbbf0ffed2e28bc7214ea446fe9cd74103f6d79f7b749b1e8b8ecc39e0f522ae1d6b4f3c1c8bd807aef7556fcf524886902eb4e664c49165ec1fe0ca40d104ed9ddd4d59dbc24ccea150dac873cbbaa5fbe0f215cdd6472c14801987d0a3527e86a60d230b2c264fed47eafd1b4ef17fc1d7d92a44fa07753addd5d4197507c8f613dc224a2444d52e0a4067317151824db7560326557f48a904906e848c177605efb53c075a546a710777694b3e268e584c10cd0e80f9e174962860f224e003bd35e20194009e2be63ea676717b04f81b6ca0fd078234de73307742ebf07bc3c988a5b2c21d05963251ba2a8e03c6c3d3f878667d5ffc85df8f84134deddabcb56be3da8311c34a9d9db02e404ed21b3570380a6aed94d94324911eeb05843ba8f7a1e58e780f87ef1119c2f58a77ad95471ae6e1befa43bab51beda2f3e9adfe743a2b07bf9e23efe75f5c525961f0a6c727fed8827dd8267f5025902e969094501c341e2b4487d889590ca3411fba2654452ccffcd400d2e4bf83b7c37bcdb601d9880bf48969eba51a533ca11ad0aa5ad0730e67a92bd4efe7baa2a589e2ad29e569c61eb385ade914224d6273b4167f09d0e0c17f2894ee79fe60f441a01adda9accb0ec3decb0c94ba252becf1f4ed4cb0455a052fb91d3ebd0c231f30708d1971962aebcbebb84ee8897c5cfd70b9b03169719e78a02eb2dc128a989b100f2c1a9d494112efdd431bb3caa11b1edea43bb26500ed05e147e83d7f61d3e7f1a4f39ca7d73ceddc60996bfd39042ce13e0f03d0a82f816b78a3a1f5ebb3e4450fe928466bfc931533a5d8fcf5b1772acf636caab3e94c37c1ccd670c21e6be31c43bfe96d3e509d2514945d10ee9ef469c8481b4f478b6d15c7c67782479306f44f9143cbdc759bc4bcbd00ddad2304de6145065e7461531f7aabd62cece65dedc492613308ff1905550b19e1fdd4a8b11295778911954c9d08069677dc975857d1d38f27db87458f3b5519444798d921dd2cd4ff82f33898d666d2e27af7c92ea152c533b76a1c6c65f1a1da0658a0d9c8f422f082bbc544ac01dbeb2d782f6d3f121b13f4e5c6ccc9ffd590200b38896d6fffc31d924bc7b2241e92bdccb0467229c1f92e22671a3318580b338c9a63553c033af91fd475e875b9ae128db66c41b922427b74d3d5f1837de9c26438feddbd92afb6423cafaab9f301dbe7371bce5f10f1538a0371c388a09a2b0f18a5d7c25d5f8f14e47ea9e3d5b6e6189d7c2494732616616fae10b98ae8562d1c67f8cfe5ca8bbe3be29ba2ff3566527dc72d327bc58880cbc78dea407a95d0ba3d0e007583321d20ce7d0f089e0c5a2c6fe799cb56db745a61fc707ce083d54a9bb4a6c84e5efc01f99cc229492da9f4973b311e19ed4bad3b30ae0276762cdb8d3f949b416a8eae263dd53921352d61f5a78825faa18f00e90e3ea18d41b4c8a6234ae519793acb05a0b7411dac9ed618c0db118e990d5e962b53a4f1b35fac4bc1aa3157b7ab452f920b59506fa082f9925486aa03f2e2bc6bb18eace5a69b67b1c8abc3cb89b947e5c56d44751cd1c9086e8630a2b3e3d385b0ab0aad61a1e4636569c74c843cd1b7c49212e44d8fc8bc0a307ce23b3995466a9a174af9a085a37d45408c7d47a2019a55ebd3db71434a7be78c16222b377b48b3bfa40c466542bf3061364912617eb2f77041036566af2a917719addca26535847c7cd42f13702871703b76a98133abe2ebdd8743441b71171981d8d69765da5826667a424c68f9c10bf111f177d53faed73158aef9e3ab2907cc35abbb16ec757e04a9a8ff4c7d28938c1d4da4d0e84e6eb610527193097942b250db9d5d2f0f8168b7ecd9ac086e06ce3a9c9b18f8d587a0af79d47471c33bbccdce9bf06b99fe8e38cfa02e88ddb9b5d7589da35aa85ad7f54c014d645c02dcc33b12fe7a2c4bae38c780c1c0b176e1fd863daab4433b9390f339cd5a17e73a9d499cea1587d0e181f68854b64837a0d4a15018c0b3d83885e6dc5a047b1397ca3aa936d890b19a5ad148c124317e513de86979ec3c4267dd3351b7821f0333ed11b3281c6921de4a84d7bab67ebb7495bfa9159abbf22e0ab45411ea545b5141bdc18c6229c74e1c44df714e1f50c86a2b6a1d9c2de19a88e94e6b6ec184811828209824e54a263e140c61e2966351c712c4580cc20368b293d256e2f4690fb663ceef408a0b2dbdcf6bee3513b77cec7a1a1a4bd1bd32605e2c3cb24486a27fbb3c14eca2d86fb457f20d29452ac1f1bb99a072fe4e4ef12f2414004f8b2aae79cdb035333a57eaf23e050c99c200e899bcdb5b2b441e8f5d09b7b71f58d8d817a3e4ef05bc921707fa81a07892ef996d4a72884a3834ca814bc8e70719186e6817c9953726326c4d9cf5e1abb11c29210830ed03406b2e5c26468e95552a6151f3b2dae956d275dd15b5fadd004aaa83d4635c47b3607cb421f47214743864b71d3b284df17f6840c199bd8e2f24f250335558932ad43287f51a590237d02daa16fb6ae05cd13c5e1072d7216eff9599df4cdaf321f105137d66817e731348ce8f2f132e5c4736f2586490daeab1ec1c2bb95e75bd327fd1e8aae469e9218704bf228a46cd6466d786671e2d01d17df2a60cf28babe86f680f7d1dae27e58d999c2c4007fff761855910007ad41d26c067b6ee6a62cf4b1c1a0291503bffd6308df8b2810b348680b33fa704a80d312ab0782f9e8cf6da038541fde5d64f4bd8d4a7c6f5bfca19b32f567f71685e445c2c5662f0e627493c1eec29981202a6dc088dea544db17d2aeb3656aeb095ac6591f969b7ba1aa60e02c000dd6328f15053ce7072c02636e2cf1defeed74dd570dd5b08d903c0ac9999d154638cbbd179a1ba7e52dcccb3ac470c598ad3d62c351a7c2782fcd603e5f0a4642fff9a47758ef4b7807b47e09e959b6e35b4e60f9ecd140d10d62e752cfa9e390524ccb5b110444413189bfde2fca1db40f082617b7d1ff9f80b59662c6112bcad8bc6bcd8eed0695259f37a7c1063bd0e303caba481eee3f6d450365c2ffeb3ef27c6cc24534e543973a479775fef7c083769936769b172c7b80a6bb999ecf439b235b5bdaa3a831aadb883bd8e5e9e9546df0b9a24e659b89f730b0adecfd6055760b2fa58d6038062bcf3b39e0621c03c14c0283002553f3ecea9cfad6cb15f07b6351a4a48b7313e3eb69042d7dbaa6be31fb64237ee7dc5c875ee545664e22db87e9e1907697c4364d1b8e1a1cef6982bf7861c3ac0e4d8d9a5af23569d054d3c99af098d11a78381cc64c299cb339d0d2ff9d424d2b32341af1a3c4899ab063d9ce7ca21f4ab12a2aa78bf9ff16981b87a5c62c6885f9c79417e74113485adbfba4a28106f039b12244319a470b760c7245fb35cc9c1c8b09d47c1ab04e86fd337a0174e5787c125db8ada9adf5b9ce6b3eefa4fbe95c5c5a1804b44148e19b7a691b72c0171a4f1a14e1fec4bb7cc0ba8c79f031f926fab25c3c2250910df9df7b273710860ba5f429f813a0e1285575b6342da3a9ecda1d6efc76a65472cf79dbeb3f536d42a2c1b9c25d1a948c8517c7577a89c2cd3f4068956e92cb3218779345b06a9ae2d1d528ba6d8f753a88cf6654d2ff675d0687a67b8994214bf2d403cefa04ff53dc00195cf9e4a3f8f753f761ef3871be15b25690f63e99fd88d63e1d1c6841a879985436074bb79bfcc7f1424b34d1361c05ae25c6ddb3b3f2bf39a68a638429d91bf1974bc84c809a67eb8b8914e029bae5336bcb9768b0f08db7986859cc7d137251a54f1b1abe42628b0d795e22506c566182182fa491ffe1e72ce592f0b967b0be52f86f3a6a8a5ebfdc5e11d4f7bc22a90a239d9de3e0a2dc43b14697f42c09327c546ec9d8c95f3b85164e5b4fdb5a007d6281f9e997eb5af4613d19083f4cca264402af05d22bc88e8309f96fe20478ff8989575818e8d00acdb9097ee1ce488a179a66b7cb60d7750aebfc8970fe8230064287b10aca1fa025766699a773e98f68da883aa8f14f553b1abd25e1aaa1dcbbbadd302d603bc39ad84ff686f71a97b594e5d57e8c3c9697a4e89370fc5a9b8ad9e8275cdb93190980dab87449896c6dfbfee59ab82dd0e81793032e114abad75cd1e3f2210f19122563e35e87094362715a62d42eaa2e46d1897f998b6156ce613c88883a62df711f59894ce62493f1421fb9fc0808a4c94d167ecfd93aa212ea016136ae0fb38966c673870758f4a99411f088acf8a5c652c976a9a71ae513b8b0c7eff5114af62b33d5bb5f58b5770dbce30056feb7a15134f5895113989957c9ec16b7eccc7393dccce04422a23249621b41683446bf79372caf5871786834ed8c88d76c79e3e8dcf08bd1639b08e5283eaef91e84e151babf8afc5d2d35ecbc1a94247127651a058a5858bc7790f3e34583f9f46de1dfd46f2913278041d633bcdb30f9da5036a52370aa3539566578aa4bd6fd975b07107852ac33de83872e82e0c308ed05ec1aac3199c431d6642711e7dff4df8def1dee3244ab550ede99180f801e877727c736774af0652fd9578db1037089bf0492250ea2f4ec72ec927e5879b22ec1a97d7d3bcb777488f866bfe2ecd2a9969d68b48538d2cf0f5aaa6ba867f23bc2232e78da659cc87d5cacb236ebd49baa1a675b2aad7ee5406b63cd0b831b8cac9bc9a0c32c4fad992552deff9a0bf73e4cd4324082cf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ff414279eaa4038c1f33f11a76d91559"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
