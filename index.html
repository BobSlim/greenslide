<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d94a6f18b09db833dfc69ff8d875ae58d680d9dfa9fdb03e3fd8ad064ecff7ecbdc204ec722fd409b3df0bc7690068d36047ff7317325f3f12d7543c95d3ea362990aa31a6979a10303604dc731650a2d54f16188b7d03f1d890a4c6780e667cb7f6fd55a17706f846960dba87e46dc628eba061fc3226c0eb2b764193e07b9e5c44f5bc2409e125cea65f7cfc5ac1fcc41075c85a1bba75b69a67b1e5e304d9be9bb698d1dc6fbee6ef6013e38ce98a04985ec25565e19da32bb24f2a7d3beccae286926b5f40810c59d7eaa851c0b9bdd8f107b3c58879222e1855837876165e34cd04ff47ccd9d3a7cde9e6d956324ac3e6f65f1e87eb39361dbdc41c4d5f3b949bad35471b30f86d5599de046de574065bf11948666ee53cbdf57f6c4e23f2f8da316fabd2ecf42dce08215c8d9bb2799b2fad323209e0d6885d973e9dd79820cb30c6b5925030779b043ae38bb862cfbcf2ba24c6823370d6ad65443954f30b545ed6c961e23e077cd304fb8f78aff1613d7f32be202f7273a94ae2d742cdb0738c0cc5ab4ebda410f71b7d89de0097c0b9ea6a9f7744b777375151d18c73a470a4fc3d9c4bafbf27c3f43ce9b2286dd62221a44e90b0869e1a6a792b7b6a707ef0c64a7589107463112aced3bb6d8ea6337cf8ff99d0ddecb83a0636712847a8228987b2b8fd31032a0def3128115a206be36b4bab6a953c7cee7a8421926738db99caa2a2d0edb04e5cbd6cd46a347a16167913b6ec15fe32875ea0e6856a1482d43032ba9af7cf34851a3cb2569b83f614a0c822440b4e2a0868e0d0c0bbb4c32e645e0cf2dfceb0d329e3fb91cbb31ba6111df2b01d286841314671526cb7ee6561202f10b2a788ee83f783730a09ba81d403a700f775694fa3a289cc804d50dc0394648c514ab44f1e0757c7d3e61bf26edaa0ad7e7b133d8506eb1a09e9e69c59f87f7174e16ad32197dd12b0b5666b091022c0a454984f44a93e3cc3949330cade079f3bdd529749f58101aabe730c75121646067a4a8a0f0736335a7b28cf0b59902e05835663306ad45359068030cc7624b24683691062f40563cf0b11993444b4a25ac463fc16b5e3a4775742ac59b9d9586b20b110edea9b68dc4b86e26f1d713d2d4ff536732a54a956aba61286f034b65740ff7d79fd4ed8b99c0d1eec03d443efae4112e837904485671eceddb6b22be425a9852351c31f015b90f1316291820bc051db795200bfed3e680759a65b7ada61f530e2e9c77802ae5e6e8a60cd1d2370adf2abdd32796c3ac5a5d128085b7cea6421a2e364c1b56b820aed867d17688f4feaa37e9eeb6b913c69dff713fb85fcf14b8c72aaec56e7136c70c199babde55cd822e5baa4191256e3ede783aa5d0dd882496acd6cd6c8db3c41fc06084d65b4caadcfbd66f06839fe7c7494cb5e8848721392c22ef544575eea8c9ecce224d21ddfbac1ff39aaa4f6eb61950f5289dde86fed05e4d7fffaaa90c7f42af5b648f9d1d35089448f3e3db8ee4229e324aaf1313fdef2e7d2abc63bf52fb3d8ab4bdfd97c211dfccca1421d9836188ba389d0a5c71231494a57ddbc0d491b88cda8b6469b9dff602105a1cbb468cc986257e451349d5d32c70e5d08c0833f6fe84c4996563b4bfb231a70b11d58e4113e190539ad43c5b09e2d8431e5025eba893e3d3335b1e0f67d50ae868c64b794250494ac167ca784ea519d38153b52d6148bce285120aa84b562d59bf34d40f4f878ed4de8f3d9a3a0c65cd7ff2bd97075009d2376a1acb589ac6dcbf5d85cace64748caedfbdb8c447e85b159d8364febe7662267847ef81d69437c84c8210ac000d089218b262b788b0b7c4e2ad352732f97c9375950c290a3d28602a0691145da8eb0964214abcb3cbc90011d16bad63005e545c9e2d7d392412442bdc277ed3ec1a726d855fdd48b904e2c1e358ce7c86133035c6de0e440bbf7aee7246f7c10bdbfd30ba31d644853e5067c30872cc35fadbb0254217321ef1df29100da7dcb38aef501f1d13b8117e0d34ff48ea744faf8f1c7cf0e601efd86a4fd6619db358fb22e84d3be538a8517307112eebd112cb464e206eee7488b3a97263fb73b3c7e9c0f0fab69719c23350a7d12279f7feba5b634061366a0feed0201c604fcd63d9c50cd136bcaad888cf5e53bfb48026f8537fcf2e70fa210979e4e97336c73806899c1de50a20b2fe2a415ecee37d6532002c5354bd4dcde96be9205e0aa2c2041a39f7bb168e0da38cf0ff04b6d268fc76df17aec76606222e9bc34f3ca0f1b2b980adf88451cc9e7fe0895b321e5a5be8cd876565ae88d488643995059b6e4506fcf197093e44d0c280a94c4d90814f69e7cc10e18632cec7fb5b1551b145be0da50fa6358ea61ed1c1d4a0597fca65664218a5cae4227c148c69df5a672687b5eb9204f62b9d0308901d54972a47eb06740d6f9fca156c9b6f01d85623147b2217b35673ccb92b858dccaf9792670277b4bbccdfafc8d19dd9f652685d746d22c8bcdd1e0bcbfc42941bd1bf6bb6eb207c0f9faff666be6ff197cbca0ff349dbdf5cb18e9a3e33f1ec7fd04f56014c9adc35a948a41aa422865213b10a889e5e5706c0ec61c4ea870e0f60dac6c669851f1eba6d43c50c2241c356fb6a3225319cfe8e82aae75835d16812b8252811a95a00a6e2b462c1f08b669451db6bfc9e14953f8102c706789ea1515a2d5b84491bdc6e1b03b7f6003496171e0aa62e6b66a3d4743f7e95e9b0c37bd05dee18482908ea3c1c1e6357c07af2a4c98d03613998c60edca19b517a6f85af7a3ecf1aa2e44eb97912d8eb6052a89f873a80da908f4c3cc5e45b06b305e12b0c5349a5bf02a422d659944e48b56034209bd7a8ec0c09b92d0b217a4e1aaa648529b69b37dab67bf548af8a9196e092f4b51388bd8537b3c1d9af0300691a0fae4bb006182ca9508ca3eca4a428fc5ccd525a7e5ba00b4a931a5a5cbb3852da611adc11b5641804006cfee9cf5cf4a55b9605cb9e5308d0f7246d9662103481ca7d850a1cf0bdd27cc4ef058e122cdb8244d93e840e165720dd9a2cfecd2139fa9d97874b6f53f577060ee3cd9c42f5404eb77988ed2c16c30850adab4f46796f8001f21c4044ca381c819e62012f46fe243855a5451716fc577bd2321c9672f7b4e3bd74e9372b3bba33aeae00ee41c63e5914c496b6888092cc04d9ac8c0c5eceb734bea178d1a7cd1dc20d55e5d8a35a1f1ebd46f4395027a6e4cce18fcfd9798d3648af8da1d7dc6e7fadca2c2dfb0d52707c0727187ad8e639129f560cbb873a0b57f09d3bc48a480d65c6388e5bf87528a96f9c500f254336643637d63cf6872041004725cbf9a7f7ccc34a72541b6324775c60a635f69f2e805acd430567cf3691dd55f9a8244552414f84ae8feae2a70015541046622112e8964936a34ed9ee6091a0e5a6c649b2ab5053ba6ca6173b780f258d4c3e20c23701398757610783fb91ae3a84d121c509cae566a9a7feb4b710edf3fadfee65f6241a6cdb245e32768f8e1e39b24eb06adabf4cfc34480946ce45c791ea95b17bbe27303f60cbe2c5567400906505474eac03982b7d7befd96b59fead64e93d32065473e32470d6560c01bb9eccbd14f6132877ab0f52ec081fd7adcc4c3548c8a6b0689a71804d971b9ca68ab1486e4085941fa507439fd85fe78c0292eb12768d58c70d2456d4943b46ed5413d60616da503278f9f2a21558e362e5f6dc2b145c17deacec7f867377ee37dac992cd0e4eaf3a8520fa09b2409b1d549eaa320868191db6c1f4797dd8fff80d67bc60e7ab7bca548eba804ab1de2f66bad5fe8732345b37c5fa53343bfe6b2eb9843116a28b0888a4abd96f90c95230fcfb609f4a73d0be44ab4bc60cd9ea774999d7a79ebf90fdce4bb8c4bd0b10ab7adc31b47d90ebfafb129301cf6e241a01577784d526bbfb3949927caeccacf9536d820040a3ed9efb3a8958797605de0d4beebaa16592339aa293c86f591d039c84fb180f600c04be812b14450b02335bf9943cf9662568ab7bb1b461f6f458d92ac5c28b27078ea9872c01419edbc9288b6dd16af044f0e2dce9a8bf93b467b19cc80445dfdbc833da77da7010f5fcb51d5d4d602050de7acd10c522c68ab66631b7e5fe0389db8fd6aa0aededba0bca56252495ba4396c10a8b2ba7ea870af5e59ca85f4e87e239710e6c168a24712437b0ad95c9a8f4a16410d93f97fb219bfefc80281677967833647c1655cb8ab189fb5578a2d56eeec2327aa0c004d0bd966bc10085c1f5c79ecb56e307b7e75193b42d496d40d2727966f86982b5481f00fcc620d77e27d98f8b90ba29f779caf8082c8b7696fa7fc6195190b2c94d8cd828b63a6980292003d98fc34df02824737ec1b35a6f12bd7692733322cdc7c17e6271dab61d8f61a37c565607c32219234dda8b3edff8d3ec9894950b1deac070420ef7b929e409223d801191cc2a648e88b39da5bb4aa40a8898dfa13f571c36e31448906e7695519e507521e7b457b7607eae34115275ad5c02d7ce406ee7b4e850b28855677839e2c577adeaf98eb0ea6dc2761201b88b9efed003ee41fbd7d6773864c7d7975542545d86083c64bd594eea061c150dacd2a6e6a26006579f5b8984cc1dfe3d669746817347d9470c7902858e83f1ad6878a5d3036e068e0b893c7d12ac24bb2db1ab27a54de9c87dbff28c94d5f9bd39acf7d2bc202a22eccbca74e8f3d4aaa984a62ca83486c64d20afd49f34b8c01fa75b96b78fa7c5cc157d3958ec7b0075997c22bc869ec218c715891807abd517248e5c0e7e98593d29dd8cfe7a5537b88a0bf1eb544a86c0d28a244b53b9d4f69534575088c2538dffe90494aa0a9eb07948e878e42b5f2ec035a8501fc8b909fa9fb8258e610f3a6e669f6381ad4dda7a32a874f9a3756ddcd6c3722ae0ed3ffd9628601eb855fb5cf57874ef9245cdd9f8917a83161675028d60be52f8df4f87877447f0f00d1543dc559442f825ae4a69a63ac795b0e672b9c3d41a6d64c7b67c859f981453bdb0d2f88e89a15a0abf4583eb0f56b426a04b4a46152bd62375e530440ed3a795061ca6c09ba44d4677b1a423b00c0eb94ff7f4c7b8b23b4cf8d151bd600ee25da3b81ad933f79196cdb599db24b82999369c83fac4d9bdcf9fc551c7e4eb0e09d98197e5e9c0f2d94389076937eed66ee78e8425004f1026cddaca251745c4a934d0c6bafe2a501be5749075c523a2ccca4064caeaeb4abf6090380f185bf3532805a77e4aca7be071397df7bd7d0a9317819db55be1dd4cebf41c7ff81217c313b5b3e9ef39f349625d54650426407065b660997d7cff260c4571fe078e29b4952992de081edd50e0e373a17eeae1dae3c351267bba935d5de5242a931ac1b903e3459789a559198ff6f42bd8c4a18ca911526377f528a0a3ccc1a877408ec33171c316cf6ef1f3d56295ed8ffb35269d88a65986931f27d46b3c67cb01bf1a0c3b35caabf4a5bd153098a4d3f1dba100abc875e84192c4179b0c8ee8572f9d18177dd47939f73b1c3b5e7773b5c268eae6354d9148a9477c8db5ebad64773e7219352ff3f56f74a3bdb79b43da76cf3b90c23af8819a94704f922347824622e84bb63810e5e29c91d24cd15b39f817375cffb74384efb2a46252bc8642659a97c0c236021811b6457ee9551d8e8b53ca24ac3d05364d4cdaf1b3b63fcae47b478ce533cbcd3040fbbbd70bcc48c305ac0a23736d2007da1580a445f3bedc7a3ea8c18c97ed97ed296a101ed0ee1443e59ba3aa03d2227214735d3010260e1da4fe6873cef0e6d5282515cfa0246644b769f3bd12dad0e837d28d9e580d7781f4c2a7d3e3639321466843c2266ba0a4e05140c8c8db4475ec34046a716f4f07df16e37c9f3e68d278efcdfcf9bbd8c739f5f984bac82e9ec780e2b8e93403978ea39088390ca331938bcbc55fa7b3074d81130991ab2512af23f36cd6b42d345f474533dbd57a4554d1f4a25c36f9626fd45f6c103db50846b35b3c59049b140f264bc99e4cb5b628bcf5cf27ed4a80e95ea3880b040f31471a0adbb50119bafa617d56f597dcba6dabacd25083243b9912965bbe263705036c075de58287cb4652bde4f0bfba86a14995e4f7cf5deadf9918cc8917025337e55a25803bced5d78e3430aa8f0142169aefbb19e53874eb9569f63ab7bab8545bc99f1dcc75f407ff93ca46360d5406149de78f54051fdd37aaae68e5ba422d31ef7efb94e8d71d8bed0e23a1995d1d60df84291a58cc555a231ae67d6c30f35650a0c1a87aad264076f78143733b2affd49bc4b2e085882180c6ce5f61cb7ad58f872f9d0126139fd9899b9456c5cc3f73df930f48d4fb3d62cdca043f3f1172a0d1bfab76ecdd989b9e2999c0466877d1c5ea66db568a92c5a4971b3f6748779a797514d880b9428d7e7293d2385194fe44e5b86f087b622c484f2112c744b2db7a840933f88e05124da18325f36e7cb27c5fbf6f456970784137ccea646ff76c9b90a337063275dc9de36964457964e21bd94f66c1c1c2fb3b0e9033c3872f553d55078c5997e4c14ff1f46ef4a284d626f44d2cc4d2fdaaa8e92a788d5113351d52920008ab55ffacb8c7bd98a6349e09c351ef94c1a4acdfca0832f911f185d8eea411fab00295fb50032c80c95a4dac4828b2f9e245a9b14a70d058d7878bf85966ec2c4800d10fbf14c59f78d3b5e37b5769858267ebd05a82225fb90d3c7c57016e4db4a4f738935cccff896b48160b0e021a279114d06d9259719ddbe15fbb903065cda56c6202b0d11698ac1b5c2f9a960201464cacfa91be57a303de63d376e45b64f06565b2e8aec817ac8aaf5cb76232bc76c3c5a9460a9220a1a48090f4ce146e565ef4f14857481e73eea373cd095134d00832402f54985ef70adfb334197964c27d05550adfe35236c12ceb8896234a8120e3d49ce32bb9ec6b41baa16d64c8f94f5efeb3000fce7ff69feed751b5cb20817995b27da9c3ce10503334f601fc97552ce2a198684e6efcb4014c08c6bee361ebd250551769f358cd299ca1ccd83a455835ca62ba3da44962dae78f5f62bbd258efa4b8225e3626ce36a48c8bab7374057c52212f178bbb0823efd9621e48ce3d0d7f2c96bdc40ceabf3c01e0398f3f1f65735ad0c758d4d68b55d9b6fd29345c89bc30ae9283ed072b0506fd418224214b79113e128389be22a9c859e8a766119297144554942897e6ed29312eae10a661be3179b9e2d7050ee29cceb261a9b8cc3bf2ab407cdba76e429f17660598d67c98eac13aeded2effae6da2214a415ad98d49956c7ec5d27440986118ad7c654fdaf12b0d92c0c830004d9cf0085990e63d9a221fdb506a1f1d7008b8f8843197ecc288742618345d75e0a9902ff9ec6c705d69fa9084f4bc3c8a3eada81c65008f6e0eb35f1dea1fd25dfa9e52dc9ac0dffb42ec6234d65bead599b007d22d9fb4d8fe882087c59a1597695dd84b041f8764ef415b08e7c550ee89e2584fc4313f97a189afb3b068b9286ab089c275dadc49c5d6ef1b3b6edcffae0f4951f1f6109af2a0a79f5219ad51800ec6f5b72fa9848a1f424cefd92850ebacc95000db93bd3b579d1f58b5e73d3d5ba35981dc54a50609ea8124b2a3feb2749099ada49f616d81af1bb47a0a1588d2fb44f4d19d47b0f54e680647fdd3f8ec03706058be1ffc03bce889f0480eb682a1d598c24f5792ea9e4101f10c477540ffc071c1540f172b7f2b8bf2b0526ec7d2393a4a03331a5478da3515bd1d7b25499fb6d7646117a3faf4850fd128d5e902cebcc5aba4e2abac601e5cce7b8c794aa735924364dbda44cf38a5c861fc29356509a0814b82cd27280e076e8e1887340308345052955917ea9d3521446a3b63e0f04ba56dedf214f91b8994b030698aff0c93a91f991006d5a90a8f817ff203df637f837766251860c68cea954d82bd1bacdd71f32922156e145c3583ddd0129568fc052b457fea6b97acb75e049169664925aa0558b8e452d291b6f6c9b10c089ebd5246d573a1162ef3afe1e77ba49a5b2fe4595f93be91d39c9716380c917dd8875c099524da966b0ff38b5f60258fe0b9ce967d7ee0e0d1cd3b160fa82b638531a0560a74abcaa07efaa997e3aaab37d769d02cfd50929ba14250c7a876333ba5deb6438fabd6819974aba90033f906af0a7d1cb3aca687362c2326504f8de2b91f225e078f8039e99712342f182251feaf0a1a1fbf2d01dc9c46e748843cd5fbbcd443194bcf90671fcaecb166f4605e5876b65ce309eac86e91edf36c85dca0c83faef90a0998bc6e8a28ac0cf2f679d22318ab5f646fb158d1c99b82028d8b98d812a0c037f74f511501841e3bc588710ab61e9492d2428260d324159fea676eabf7ddce3ca641ddf120253d8b6b04072d1f35a10fedb4b4b338706cc12e8343ac006ecf320b86a53edbbb56cdbb6bad50dfa66a4ba38caeff0863833f94fbc954fbc473c328a7a4638806b9572c9ef0ebb59622e2ae91552aac937fb669d83a6e254b2a0765118532ed5ab62d3e8cd40c3993b79d5fda752458cad3a06d59f615b1f7c433311c014ff29a65afece847777bff1ffabc35a6fbb979b28aad0ca5d893b17b7b29e788a340c660ca9fa816329d3b0e60783ec89b7f1f6e8aa1368b26116e8feed9c5af533827f471c071e2f0a8586e380a47c3f025633caef4e7282ab703a740bab87a94ac1544332e69c6bdaa23d716f502e706716c7fb50755f0d4627545bbd972591b77d688b42c82166811a7e58fba5721bc10ff1911d0e57b0601d82ec171128f3cf6c272bc9f841622adac0f511d883311d99467ab87c4c67c2e89c7c15316b6f7ecf92b45a9a8fc86d6d9a423ecf733ac9f0beff8188c44660cfdce3d1e27ca9e786210ffa5720d9c83ae3fd34319292558f6baec227b0325776355cec2aa17cf87a8d94d166dfe3a8b8076a1f0d7adc4e1db3e98b1787b77ac5cb2f484ad0850d78dd57434e0c63a52530e33a5d2dc92cf8012ed417ca827385e4453a5aa73864f5e3c7ed195e41c100214f8c1da2a1e9cfd70617df2f3426660e7530c0c502d23c20c0222d1ecb4d0bbb8df7ea3005d648249bab38fa1472be95b2699ac0d3f05608d2365140f181d59364e48baaab574056ebe6fd8011b4faab2403518f651546c6b17613181f0f5872edc4915e4c370c394a3a776529cf4639f115197ae81554c7ea777ed4c30c0e3a6e3564e0b0e5531483b899e563d7fc5d8388fccc4c082723b4d62e1c42ca90fe107e3a3374e05c9c28ee5d9a586419e2a97deb38ff6c3dd86ca94b8334a0dd5943334011199c5d625b51a3fa345e8fabbc70bdd984c82c565aa25d8df74338d8e5c49d5f031219aad2a6000d7d032a7b1445107083adc8c756028d62e4f00641840cd720ce77a155b78e5ecee2c54820f42a616e5c052756e0894d883020f0625eaf3b0c2331945289a98ff848424a5cc52cf80c9f3935ee8cd0d6d59ec0ecf0f06e27cd6f3f91a377dd15e6f3838fdd7b89621f71686f3b48b3350c809e5a2344cef3588f253c8a7a0362f52018bcdbb69167ba7ac210138cfe4bccabc97cbbdee4ea879f6f3e17cf4ad1b5ed997272440136b6ef4d7c30378cd6136166b161526df631381ff4abc944a5a89c20aaeb2d5be3b97e253415d59d474efd472e7924aee9a6bc6699e431c25d26f7b3f146ecf9c6ce91c5b4268d0299a72dccf0f24d4d03741f2dc83f9239dc59e635402631338a1b1e21d2a20a6c103c9a214b30345b9da715bac3949e5199b3f28dc3db607d042b1a19c141efa996c470d7ee6561312017308c2080b2a0d1cab1b5836dbbfe79bb1665c0efdee3419b307e32f7d3383f1bc3282e6190c5b0b5ac6768977fe8a719a8f0fe7705ac220aa3ed2cbb1ab14f0a5c9da9fad107e493ebc40171c683635c2b314d9addb1860007d746a51e32698bea6e14d0c45320c541cfd06adf2b552c774d0b034e20b06c3127fd0186f2244cea3939ef41de4bf24780ab4b8bb176364dd1fc010b8278956905764e5262213cd0e400e0e5e9d28f1aa2eee21147ab2569d9c743c8f8aee7a7df63b2dad75dbd8b5ad2ff96974a1269f11c69ef9066fefd6a970cf23029e3fc6ceaed40292efc1b8fbe658c6c440ace09aefaf9425767104a5b1930fe257f216246b08bb5ebe513fe914c802db4a6c72ba1b776446929bfa8492e7fd1a1f8edee98b06fde0bf4bd22c07e89a8f1be573cf909a3b6e65267146d96b7cf8c219d9c3876e2e176a82a15db5fa30461d49215a56853d7bfcbfeb03fb5f4c3865f3fbce5d6c7ebafba25e89254d0c53be6231f51bb20c6f262d31fed78bb01200db485b1b27484bcd2af849eff41c709d0df9213f79fb28c4252bd91411eea11d014f0a25c5a6ae1ccc1c94ad13f8a4dc241035b787d2ea09d8652f7d85dc05df21920ca68f883444eb16e42bc65ef36b5bcb0957d19f4fa396991e1c29c499f7e8cb365affaed0cd197c261161711c836d359b1da5cf04c5e7a2454a53591ff13c8946fe03cd44307cae8fd2fa1772cefe9333a5719b4f9c36a0dc7ed7799ee554a604a652f1db15b77d76d7ea0c4ba12f06270d9cb515df87ca401cd4e838ce6436ef24c9618b0a7aa424aa65b86dfb5e35f1079cdbe7258bc2a6421103cc66c1722f402a9ec73227c0d59277fe2978ae01c4490fea1534c8bcb66644030528204709c6f18a156dbfcbc84224f37dee205ea136e84cd5f2616323e46ab249256b64b0847f440f528013c4b420c55c77528f87cc92a27c42e6c8e57ad7afb3d099a99ce09d6c5512da0ddc4859a0d679ac60d8ff390b7055a37bd535d3e77b06156c73292de67db06fb04d2d74c3e9b20c02f7b63feaeacf5c15fd152e638328b3278658dbf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"0837d7e6644d0db5ae3a38e101912e8d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
